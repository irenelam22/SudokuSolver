# Testing

### Testing Strategy

For our testing strategy, we ran our `create` and `solve` program against invalid arguments and on multiple cases to check robustness. We further specified our testing to the specific functionality of each program to ensure accuracy. 

Making test this way will default to FuzzTest getting an input of 2. Alternatively, you can also change the number of tests generated by navigating into the `testing` directory and running the following command: `./FuzzTest.sh [N]`

>You can generate all the testing scripts at once if in the main directory by running `make` and `make test`. 

There are three main files to look at:

1. `FuzzTest.sh`: a shell script that accepts a number from the user, representing the number of tests to generate. This script will call the `create` function, save the output into a provided file (*testing.txt*), and then pass the puzzle generated into the solve function. From there, the `solve` program will solve it and then return the solved sudoku to a different file (*fuzz.out*)

2. `UnitTester.sh`: our unit testing main script. The shell script is subdivided into two parts, the first half testing the create functionality of the code and the latter half testing the solver aspect of it. We decided these tests in one shell script after discussing with Professor Zhou and TA Rachael Chacko, as the file tests are mutually related. 

	* The `create` portion of the code checks to see if create works by generating several valid sudoku puzzles. We manually check their validity, and compare the files to ensure there are differences to make the puzzles "unique" (please see our pseudo-proof for more information on why we can't guarantee uniqueness). We further test the validity of create by passing the sudoku puzzles to the solver to check if any errors arise. 

	* The `solve` portion of the code is tested on a range of inputs, including but not limited to the following:
		- Bad input 
			- Puzzle with insufficient number of lines
			- Puzzle incorrectly formatted (e.g. too many/little pipes)
			- Puzzle with too many/little numbers
			- Puzzle with incorrect numbers (e.g. integers greater than 9)
		- Invalid puzzle (puzzle with no solution because it already violates the rules of sudoku)
		- Empty puzzle (i.e. a puzzle with nonunique solutions): the solver should return one solution
		- Testing on several puzzles with known solutions and manually check for correctness
		- Testing on several puzzles produced by `create` with unknown solutions and manually check for correctness

	For all of these cases, we ensure that `solve` completes the puzzle (if a solution exists) or returns a corresponding error message if no such solution is found.

3. `Testing.sh`: runs both of the tests previously mentioned. This testing script also accepts one argument in order to pass that argument into FuzzTest, which corresponds with the number of tests generated. We created these files to consolidate our tests, but all of the main tests are handled within our integration and unit tests.

4. We also have a minor puzzle unit test in `common/puzzle_unittest.c`. As this was not part of the assignment's main testing plan per our previous conversations with Professor Zhou, we decided to keep this test in the `common` directory. This puzzle unit test tests specific methods used by create, solve, and the ncurses extra credit code, including but not limited to retrieving the next unit, updating the possibles list, checking the puzzle is solveable, and checking that the puzzle is finished.


### Pseudo Code: Testing

#### FuzzTest.sh:

1. For i =1 until the user input number:
	1. Run create *i* number of times and save each input into a file
	2. Run solver *i* number of times and pass it the files just created each time 
	3. Save the output of solver into a fuzz.out file and append it after each iteration
2. Clean up

#### Unit Testing:

Create:

1. Run ../sudoku/sudoku create three times
2. Save each of the outputs to a corresponding file
3. Compare the files to make sure each of the files generated is unique
4. Pass the files generated into the Solver to make sure that these sudokus are in fact solveable and do not contain any types of errors. 

Solver:

1. Test the solver using numerous edge cases including but not limited to the following:
	1. Passing in a puzzle that is not a sudoku 
	2. Passing in a puzzle that does not contain the proper format
	3. Passing in a puzzle that has a number outside of the bounds
	4. Passing in an empty puzzle and shows it will only generate one puzzle even if it has nonunique answers
	5. Passing in 2 valid puzzles whose solutions we know beforehand
2. Test that the solution generated by the solver matches the right answer.


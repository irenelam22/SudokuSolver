# Testing

###Testing Strategy

For our testing our stragedy we centered it around trying to run as many cases as we possibly could and see how our code reacted. We made the test cases quite robust in order to accruately gauge our code's efficiency. There are three files to look at. 
>You can generate all the testing scripts at once if in the main directory you: make clean, make, and then make test. Making test this way will default to FuzzTest getting an input of 2. If you want to change the number of tests generated by FuzzTest you will need to run the executable directly: ./FuzzTest.sh [N]

1. FuzzTest.sh which is a shell script, intakes one input from the user which is the number of tests to generate. This script will call the create function save the output to a file that is then passed into the solve function which will solve it and then return the solved sudoku to a different file called fuzz.out
2. Unit Testing- Our Unit Testing is all done in one shell script. The shell script is subdivided into two parts, the first half tests the create functionality of the code and the latter half tests the solver aspect of it. The first couple of lines of the create function tester checks to see if it is properly working by generating valid sudokus. We check their validity by passing the sudokus to the solver and seeing if any errors arise. We check solver a little more intensely by passing it a myriad of different test scenarios.  We  directly pass it invalid sudokus of various types such as incorrect formatting to incorrect numbers and blank sudokus. Then we pass valid sudokus and compare the results to the right answer to make sure our solve code generated the appropriate solution.
3. Testing.sh just runs both of the tests previously mentioned. This testing script also intakes one argument in order to pass that argument into FuzzTest, which corresponds with the number of tests generated. 

###Pseudo Code: Testing

For FuzzTest.sh:

~~~
For i =1 until the user input number:
	Run create and save input into a file
	Run solver and pass it the files just created
	Save the output of solver into a fuzz.out file and
	append it after each iteration
end
~~~
For Unit Testing:

Create:

~~~
Run ../sudoku/sudoku create three times
Save each of the outputs to a corresponding file
Compare the files to make sure each of the files generated 
is unique
Pass the files generated into the Solver to make sure 
that these sudokus are in fact solveable and do not contain any types
of errors. 
~~~
Solver:

~~~
We test the solver using numerous edge cases:
Passing in a puzzle that is not a sudoku 
Passing in a puzzle that does not contain the proper format
Passing in a puzzle that has a number outside of the bounds
Passing in an empty puzzle and shows it will only generate one puzzle
even if it has nonunique answers
Passing in 2 valid puzzles whose solutions we know before hand
Test that the solution generated by the solver matches the right
answer.
~~~

# Sudoku Implementation Spec
### Team KIDD - Kelly Westkaemper, Irene Lam, David Kantor, David Perez Gonzalez 
### Dartmouth CS50, Summer 2020

### Overview

The specific data structures are defined in the sections below.

`Sudoku` supports two features: generating a new 9x9 puzzle, or solving a given 9x9 puzzle. For create, the program optionally takes difficulty level, otherwise defaulting to 'medium' difficulty, and randomly generates a sudoku puzzle. For the latter, the program takes in a puzzle-formatted file (or reads from stdin) and prints to stdout the solution, if any.

### create
`Create` randomly generates an unfinished sudoku puzzle with at least 40 missing numbers. It also supports multiple difficulty levels, each with different ranges of numbers shown, as described in README.md. 

It first creates an empty puzzle, then recursively fills in each number, checking to make sure the rules of sudoku are held. Next, it randomly removes numbers from the puzzle, checking to make sure there's one unique solution. More specifically, it checks our best approximation of whether there is one solution, because it is impossible to guarantee that a given sudoku puzzle has only one solution, as described more in our pseudo-proof. Once enough numbers have been removed, create then prints the unfinished puzzle to either standard output, if the user didn't provide any parameters, or to the file name that the user provided. <br/>
`Create` uses a *unit* and *puzzle* data structure to keep track of the information within a given sudoku puzzle. Within *unit*, *possibles* is a *counters* data structure that stores the possible numbers that each unit can take. See the README.md for more information.  <br/>
The `create` module implements the following methods: 
(Please see pseudocode for pseudocode implementation.)
```c
/******* create *******/
/* Main creating functionality 
*  Inputs:
*	filename of where to print the puzzle 
*	indicator (1 if printing to stdout, 0 if printing to file)
*  Output: 
*   printed puzzle, to either stdout or given filename
*/
void create(char* file_name, int indicator);

/******* fill_puzzle *******/
/* Randomly fills in the entire puzzle, making sure sudoku rules are held 
*  Input: puzzle struct 
*  Output: true if puzzle filled properly, false otherwise 
*/
bool fill_puzzle(puzzle_t *puzzle);

/******* hide_nums *******/
/* Randomly selects units to remove from the given puzzle 
*  Inputs: 
*     * puzzle: current puzzle struct 
*     * fullpuzz: the solved full version of puzzle, as generated 
*                 by fill_puzzle
*     * minshown: the minimum amount of numbers to be shown
* Output: 
*     * true if enough numbers are hidden (at least 40), false otherwise 
*/
bool hide_nums(puzzle_t *puzzle, puzzle_t *fullpuzz, int minshown);

/****** remove_random_num*********/
/* Randomly removes one unit from a given puzzle
 * Inputs: 
 *      * puzzle: current puzzle struct to remove from
 *      * numshown: pointer to the current number of units shown in the puzzle
 * Output: 
 *      * value of the unit removed from the puzzle, in case it needs to get added back  
 */
remove_random_num(puzzle_t *puzzle, int *numshown);

/******* has_one_solution *******/
/* Our best estimate of testing to see if a puzzle has one unique solution
*  
*  Given both an unsolved puzzle and its solution, it calls fill_puzzle 
*  on the unsolved puzzle to generate a random solution, then compares
*  the two puzzles to see if the random solution matches the given solution
* 
* Inputs: 
*      * puzzle: current puzzle struct 
*      * fullpuzz: solution of current puzzle struct, as generated by 
*                  fill_puzzle
* Output: 
*      * true if the puzzles match, false otherwise 
*/
bool has_one_solution(puzzle_t *puzzle, puzzle_t *fullpuzz);

/******* copy_puzzle *******/
/* Helper function for puzzle_iterate that copies all data values for one 
*  puzzle into another
*/
void copy_puzzle(void *arg, unit_t* unit);
```

### Pseudo code for create
The `create.c` implementation runs as follows: 
1. Execute from a command line with the usage syntax `./sudoku create [difficultyLevel]`
2. Validate arguments:
   * File pointer must be valid
   * Minimum numbers to show must be greater than 0, less than 41 
3. Create an empty puzzle 
4. Fill the puzzle randomly, using recursion
   * Same process as the pseudocode described below in Solve under #4, except *fill_puzzle* gets random numbers from the possibles list
5. Store the full puzzle in another puzzle struct, for later comparison with *has_one_solution*
6. Hide numbers in the puzzle randomly one by one, comparing the current puzzle's solution to the complete puzzle to ensure there's only one unique solution, and staying within the number of shown numbers as indicated by difficulty level (described in README.md) 
	* If hide_nums returns false, i.e. not enough numbers were hidden, then copy the full puzzle into the current puzzle and re-run hide_nums
7. Print the puzzle to the given file, or if none given, to standard output
8. Clean up memory

### solve

`Solve` reads a puzzle-formatted file to determine whether a valid solution exists for the given file. In particular, `solve` recursively tests each possible number to determine whether such a solution exists, and returns this solution if true. If no solutions exists or if there were issues with inputs, `solve` will return the corresponding error.

Similarly to create, `solve` uses a *unit* and *puzzle* data structure to keep track of the values within the sudoku puzzle. In addition, `unit` also uses a *counterset* data structure to store the possible numbers each unit can take. Please see the README for definitions, or see below for further implementation.

The `solve` module implements the following methods:
(Please see pseudocode for pseudocode implementation.)
(Please note that as implemented, these methods may not be organized into
the same directory)
```c
/******* solve ********/
/* Main driver method for solve
 * Input:
 * file_name: the pathname of a puzzle-formatted file
 * Output: none (directly prints the puzzle to stdout)
 */
void solve(char* file_name);

/*******solve_puzzle********/
/* Fills in the entire puzzle (main solving method)
 * Inputs: puzzle
 * Output: true if solved, false otherwise
 */
bool solve_puzzle(puzzle_t* puzzle);

/*******first_valid_unit********/
/* Finds the first unit within a puzzle not yet filled in
 * itemfunc method to be called in puzzle_iterate
 * Inputs: pointer, current cell
 * Output: none (directly populates ptr)
*/
void first_valid_unit(void* ptr, unit_t* current_cell);

/*******next_unit********/
/* Finds the first unit within a puzzle not yet filled in
 * Inputs: puzzle
 * Output: unit
*/
unit_t* next_unit(puzzle_t* puzzle);

/******* possibles_create ********/
/* Creates a possibles set, based on values in the row/col/box
 * Inputs: puzzle, unit
 * Output: newly created set
*/
counters_t* possibles_create(puzzle_t* puzzle, unit_t* unit);

/******* updating_possibles ********/
/* Updates the list of possible numbers by traversing through puzzle
 * and removing values that appear in the row, column, and box
 * Inputs: puzzle, unit
 * Output: none
*/
void updating_possibles(puzzle_t* puzzle, unit_t* unit);

/******* updating_possibles_helper ********/
/* Updates the list of possible numbers by traversing through puzzle
 * and removing values that appear in the row, column, and box
 * itemfunc method for updating_possibles
 * Inputs: arg (unit -- to be modified), unit (that is compared)
 * Output: none
*/
void updating_possibles_helper(void *arg, unit_t* unit);

/******* solveable_helper ********/
/* Checks whether a puzzle is solveable (e.g. all units have a possible value)
 * itemfunc for is_puzzle_solveable
 * Inputs: pointer (boolean), unit
 * Output: none
*/
void solveable_helper(void* ptr, unit_t* current_cell);

/******* is_puzzle_solveable ********/
/* Checks whether a puzzle is solveable (e.g. all units have a possible value)
 * Inputs: puzzle
 * Output: true if solveable, false otherwise
*/
bool is_puzzle_solveable(puzzle_t* puzzle);
```

### Pseudo code for solve

The `solve.c` implementation runs as follows (using C):
1. Execute from a command line with usage syntax `./sudoku solve PUZZLE_FILE_NAME`
2. Validate its command-line arguments:
   1. Ensure `PUZZLE_FILE_NAME` is the pathname for an existing readable file, formatted as a puzzle
3. Load the index from `PUZZLE_FILE_NAME` into an internal puzzle data structure.
4. Solve the puzzle recursively.
   1. Retrieve the next fillable unit within the puzzle
   2. Until the next unit is not NULL, continue (as NULL indicates that the puzzle is solved)
   3. Create a possibles list for this unit
   4. If there are no possible numbers to input in this unit (i.e. possibls is empty)
       1. Delete the possibles list
       2. Set the value of the unit to the empty-cell value
       3. Return false as there is no solution using the current puzzle values
   5. For each possible number, p, in the unit
       1. Set the unit value to be p
       2. Solve the puzzle with the newly changed puzzle and return true if solveable
       3. Otherwise, remove the value from the list of possibles as it did not result in a solveable solution
5. Clean up and return false as there is no solution to the puzzle


### Testing plan

To test the output of `create.c` and `solve.c`, we run several hard-coded examples as well as `FuzzTest` inputs and manually check the outputs. Both modules have their respective unit tests, as well as an integration test to test the program's functionality as a whole.

In particular, we check that `create` will create as close to a unique puzzle as possible (please see README and extended pseudo-proof for how we guarantee uniqueness but we ran out of time to implement). 

Similarly, we check that `solve` will correctly solve a puzzle with a known solution. We also use various `fuzzquery` tests with known sudoku puzzle solutions and invalid inputs to ensure robustness. For example, we test `solve` on puzzles with different amounts of units filled in to test the accuracy of backtracing/the recursive process. 

Lastly we have a 'testing.sh' shell script that will make clean make and then run both of the tests previously mentioned to increase the efficiency of running test cases. 


Please see `TESTING.md` for more testing specific examples.
